aws_region = "us-east-1"
kubectl = "kubectl --context=miner-${aws_region}"

default_miner_image = "spacemeshos/go-spacemesh:787b038"
init_miner_image    = "534354616613.dkr.ecr.us-east-1.amazonaws.com/spacemesh-testnet-miner-init:latest"

/* FIXME: Move to ConfigMap */
coin_base = "0x1234"
poet_url  = "spacemesh-testnet-poet-grpc-lb-f34cb9e80d3b5d58.elb.us-east-1.amazonaws.com:50002"

/* Pipeline global vars */
def miner_count
def worker_ports = []
def bootstrap_addr
def bootstrap_pod
def bootstrap_tcp_port
def bootstrap_grpc_port
def bootstrap_id
def bootnodes

def get_bootstrap_pod = {pool_id ->
  """\
  ${kubectl} get pod -l miner-node=miner-${pool_id}-bootstrap --template '{{\$i := index .items 0 }}{{\$i.metadata.name}} {{\$i.status.phase}} {{\$i.spec.nodeName}}' 2>/dev/null
  """.stripIndent().trim()
}

def bootstrap_manifest = {pool_id, miner_image ->
  """\
  ---
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: miner-${pool_id}-bootstrap
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
      miner-node: miner-${pool_id}-bootstrap
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: miner-bootstrap
    template:
      metadata:
        labels:
          app: miner-bootstrap
          miner-pool: \"${pool_id}\"
          miner-node: miner-${pool_id}-bootstrap
      spec:
        volumes:
          - name: miner-storage
            emptyDir: {}

        initContainers:
          - name: miner-init
            image: \"${init_miner_image}\"
            env:
              - name: SPACEMESH_S3_BUCKET
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_bucket
              - name: SPACEMESH_S3_PREFIX
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_prefix
              - name: SPACEMESH_DYNAMODB_TABLE
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_table
              - name: SPACEMESH_DYNAMODB_REGION
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_region
              - name: SPACEMESH_WORKER_ID
                valueFrom:
                  fieldRef:
                    fieldPath: metadata.name
              - name: SPACEMESH_WORKDIR
                value: "/root"
              - name: SPACEMESH_DATADIR
                value: "./post/data"

            volumeMounts:
              - name: miner-storage
                mountPath: /root

        containers:
          - name: default
            image: \"${miner_image}\"
            imagePullPolicy: "Always"
            env:
              - name: SPACEMESH_MINER_PORT
                value: \"${bootstrap_tcp_port}\"
              - name: SPACEMESH_GRPC_PORT
                value: \"${bootstrap_grpc_port}\"
              - name: SPACEMESH_COINBASE
                value: \"${coin_base}\"
              - name: SPACEMESH_POET_GRPC
                value: \"${poet_url}\"
            args: [ "--config", "/root/config.toml",
                    "--grpc-server", "--grpc-port", \$(SPACEMESH_GRPC_PORT),
                    "--tcp-port",    \$(SPACEMESH_MINER_PORT),
                    "--coinbase",    \$(SPACEMESH_COINBASE),
                    "--poet-server", \$(SPACEMESH_POET_GRPC),
                    "--genesis-time", \"${params.GENESIS_TIME}\",
                  ]
            resources:
              limits:
                cpu: 1000m
              requests:
                cpu: 100m
            volumeMounts:
              - name: miner-storage
                mountPath: /root
  """.stripIndent()
}

def worker_manifest = {pool_id, miner_image, worker_id, tcp_port, grpc_port, json_port ->
  """\
  ---
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: miner-${pool_id}-node-${worker_id}
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
      miner-node: miner-${pool_id}-node-${worker_id}
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: miner
    template:
      metadata:
        labels:
          app: miner
          miner-pool: \"${pool_id}\"
          miner-node: miner-${pool_id}-node-${worker_id}
      spec:
        volumes:
          - name: miner-storage
            emptyDir: {}

        initContainers:
          - name: miner-init
            image: \"${init_miner_image}\"
            env:
              - name: SPACEMESH_S3_BUCKET
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_bucket
              - name: SPACEMESH_S3_PREFIX
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_prefix
              - name: SPACEMESH_DYNAMODB_TABLE
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_table
              - name: SPACEMESH_DYNAMODB_REGION
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_region
              - name: SPACEMESH_WORKER_ID
                valueFrom:
                  fieldRef:
                    fieldPath: metadata.name
              - name: SPACEMESH_WORKDIR
                value: "/root"
              - name: SPACEMESH_DATADIR
                value: "./post/data"

            volumeMounts:
              - name: miner-storage
                mountPath: /root

        containers:
          - name: default
            image: \"${miner_image}\"
            imagePullPolicy: "Always"
            env:
              - name: SPACEMESH_MINER_PORT
                value: \"${tcp_port}\"
              - name: SPACEMESH_GRPC_PORT
                value: \"${grpc_port}\"
              - name: SPACEMESH_JSON_PORT
                value: \"${json_port}\"
              - name: SPACEMESH_COINBASE
                value: \"${coin_base}\"
              - name: SPACEMESH_POET_GRPC
                value: \"${poet_url}\"
            args: [ "--config", "/root/config.toml",
                    "--tcp-port", \$(SPACEMESH_MINER_PORT),
                    "--coinbase",    \$(SPACEMESH_COINBASE),
                    "--poet-server", \$(SPACEMESH_POET_GRPC),
                    "--genesis-time", \"${params.GENESIS_TIME}\",
                    "--bootstrap", "--bootnodes", \"${bootnodes}\",
                  ]
            resources:
              limits:
                cpu: 1000m
              requests:
                cpu: 100m
            volumeMounts:
              - name: miner-storage
                mountPath: /root
  """.stripIndent()
}

def get_node_inst_id = {node ->
  """\
  ${kubectl} get node ${node} --template '{{.spec.providerID}}' | sed -e 's/.\\+\\///'
  """.stripIndent()
}

def get_instance_ip = {inst_id ->
  """\
  aws ec2 describe-instances --region=${aws_region} --instance-ids ${inst_id} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text
  """.stripIndent()
}

def get_bootstrap_id = {pod ->
  """\
  ${kubectl} logs ${pod} --tail=-1 -f |\\
  sed -ne '/Local node identity / { s/.\\+Local node identity >> \\([a-zA-Z0-9]\\+\\).*/\\1/ ; p; q; }'
  """.stripIndent()
}


/*
  PIPELINE
 */
pipeline {
  agent any

  options {
    buildDiscarder(logRotator(numToKeepStr: '5')) // Keep last 5 builds only
  }

  parameters {
    string name: 'MINER_COUNT', defaultValue: '', description: 'Number of the miners to start', trim: true
    string name: 'MINER_IMAGE', defaultValue: default_miner_image, description: 'Miner pool id', trim: true
    string name: 'POOL_ID',     defaultValue: '', description: 'Miner pool id', trim: true
    string name: 'GENESIS_TIME', defaultValue: '', description: 'Genesis time', trim: true
  }

  stages {
    stage("Prepare") {
      steps {
        script {
          miner_count = params.MINER_COUNT as int
          assert miner_count > 0
          pool_id = params.POOL_ID ?: random_id()
        }
        echo "Number of miners: ${miner_count}"
        echo "Miner pool ID: ${pool_id}"
      }
    }

    stage("Create services") {
      steps {
        script {
          def boot_node = "miner-${pool_id}-bootstrap"
          bootstrap_tcp_port = create_miner_services(pool_id, boot_node)
          bootstrap_grpc_port = create_service("${boot_node}-grpc", pool_id, boot_node, "TCP", 9091)
        }

        echo """\
          Bootstrap TCP/UDP port: ${bootstrap_tcp_port}
          Bootstrap GRPC port: ${bootstrap_grpc_port}""".stripIndent()

        script {
          for(i in (1..(miner_count-1)).collect()) {
            def ports = [
                         tcp_port: create_miner_services(pool_id, "miner-${pool_id}-node-${i}"),
                        ]
            worker_ports.add(ports)
            echo """Worker #${i} TCP/UDP port: ${ports.tcp_port}"""
          }
        }
      }
    }

    /* FIXME: Add PVC here */

    stage("Create bootstrap miner") {
      steps {
        echo "Generating manifest"
        writeFile file: "bootstrap-${pool_id}-deploy.yml", text: bootstrap_manifest(pool_id, params.MINER_IMAGE)
        echo "Creating bootstrap Deployment"
        sh """${kubectl} create -f bootstrap-${pool_id}-deploy.yml"""
        echo "Waiting for the bootstrap pod to be scheduled..."
        script {
          def pod_node

          /* Wait until a pod in a Running state appears */
          timeout(time: 600, unit: 'SECONDS') {
            waitUntil {
              try {
                (bootstrap_pod, pod_status, pod_node) = shell(get_bootstrap_pod(pool_id, miner_image)).split()
                pod_status == "Running"
              } catch(all) {
                false
              }
            }
          }

          echo "Running on node ${pod_node}, getting AWS instance id"
          def inst_id = shell(get_node_inst_id(pod_node))

          echo "Getting AWS instance '${inst_id}' public IP"
          bootstrap_addr = shell(get_instance_ip(inst_id))
        }
        echo "Bootstrapping from: ${bootstrap_addr}:${bootstrap_tcp_port}"

        echo "Getting bootstrap miner_id from the logs"
        script {
          timeout(time: 600, unit: 'SECONDS') {
            bootstrap_id = shell(get_bootstrap_id(bootstrap_pod))
          }
        }
        echo "Bootstrap ID: ${bootstrap_id}"

        script {
          bootnodes = "spacemesh://${bootstrap_id}@${bootstrap_addr}:${bootstrap_tcp_port}"
        }

        echo """\
          Bootstrap nodes: ${bootnodes}
          PoET --nodeaddr: ${bootstrap_addr}:${bootstrap_grpc_port}
          """.stripIndent()
      }
    }

    stage("Create workers") {
      steps {
        script {
          worker_ports.eachWithIndex({ports, i ->
            i++
            echo "Generating manifest for worker #${i}"
            writeFile file: "miner-${pool_id}-node-${i}-deploy.yml", \
                      text: worker_manifest(pool_id, params.MINER_IMAGE, i,
                                            ports.tcp_port,
                                            ports.grpc_port,
                                            ports.json_port,
                                            )
            echo "Creating Deployment for worker #${i}"
            sh """${kubectl} create -f miner-${pool_id}-node-${i}-deploy.yml"""
          })
        }
      }
    }

    stage("Archive artifacts") {
      steps {
        archiveArtifacts "*-${pool_id}-*.yml"
      }
    }
  }
}

def create_service(svc, pool_id, node, proto, port) {
  echo "Writing service manifest for ${svc}"
  writeFile file: "${svc}-svc.yml", text: """\
  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: ${svc}
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
  spec:
    type: NodePort
    selector:
      miner-node: \"${node}\"
    ports:
    - protocol: ${proto.toUpperCase()}
      port: ${port}
  """.stripIndent()

  echo "Creating service ${svc}"
  sh """${kubectl} create -f ${svc}-svc.yml"""

  echo "Getting allocated port"
  return get_service_port(svc)
}

def get_service_port(svc) {
  return shell("""${kubectl} get svc ${svc} --template '{{(index .spec.ports 0).nodePort}}'""")
}

def create_miner_services(pool_id, node) {
  def svc = "${node}"

  echo "Creating mock service for ${svc}"
  sh """\
  ${kubectl} create -f - <<EOF
  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: mock-${svc}
    labels:
      app: miner
  spec:
    type: NodePort
    ports:
    - protocol: TCP
      port: 7513
  EOF
  """.stripIndent()

  echo "Getting allocated port"
  def port = get_service_port("mock-${svc}")
  echo "Port: ${port}"

  echo "Deleting mock service"
  sh """${kubectl} delete svc mock-${svc}"""

  echo "Creating manifest for service ${svc}"
  writeFile file: "${svc}-svc.yml", text: """
  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: ${svc}
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
  spec:
    type: NodePort
    selector:
      miner-node: \"${node}\"
    ports:
    - name: tcp-port
      protocol: TCP
      port: ${port}
      nodePort: ${port}
    - name: udp-port
      protocol: UDP
      port: ${port}
      nodePort: ${port}
  """.stripIndent()

  sleep 1

  echo "Creating service ${svc}"
  sh """${kubectl} create -f ${svc}-svc.yml"""

  return port
}

/* vim: set filetype=groovy ts=2 sw=2 et : */
