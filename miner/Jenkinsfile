aws_region = "us-east-1"
kubectl = "kubectl --context=miner-${aws_region}"

default_miner_image = "spacemeshos/go-spacemesh:787b038"
init_miner_image    = "534354616613.dkr.ecr.us-east-1.amazonaws.com/spacemesh-testnet-miner-init:latest"

/* FIXME: Move to ConfigMap */
coin_base = "0x1234"
poet_url  = "spacemesh-testnet-poet-grpc-lb-f34cb9e80d3b5d58.elb.us-east-1.amazonaws.com:50002"

/* Pipeline global vars */
def miner_count
def worker_ports = []
def bootstrap_addr
def bootstrap_pod
def bootstrap_tcp_port
def bootstrap_json_port
def bootstrap_grpc_port
def bootstrap_id
def bootnodes

def get_bootstrap_pod = {pool_id ->
  """\
  ${kubectl} get pod -l miner-node=miner-${pool_id}-bootstrap --template '{{\$i := index .items 0 }}{{\$i.metadata.name}} {{\$i.status.phase}} {{\$i.spec.nodeName}}' 2>/dev/null
  """.stripIndent().trim()
}

def bootstrap_manifest = {pool_id, miner_image ->
  """
  ---
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: miner-${pool_id}-bootstrap
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
      miner-node: miner-${pool_id}-bootstrap
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: miner-bootstrap
    template:
      metadata:
        labels:
          app: miner-bootstrap
          miner-pool: \"${pool_id}\"
          miner-node: miner-${pool_id}-bootstrap
      spec:
        volumes:
          - name: miner-storage
            emptyDir: {}

        initContainers:
          - name: miner-init
            image: \"${init_miner_image}\"
            env:
              - name: SPACEMESH_S3_BUCKET
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_bucket
              - name: SPACEMESH_S3_PREFIX
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_prefix
              - name: SPACEMESH_DYNAMODB_TABLE
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_table
              - name: SPACEMESH_DYNAMODB_REGION
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_region
              - name: SPACEMESH_WORKDIR
                value: "/root"
              - name: SPACEMESH_DATADIR
                value: "./post/data"

            volumeMounts:
              - name: miner-storage
                mountPath: /root

        containers:
          - name: default
            image: \"${miner_image}\"
            imagePullPolicy: "Always"
            env:
              - name: SPACEMESH_MINER_PORT
                value: \"${bootstrap_tcp_port}\"
              - name: SPACEMESH_GRPC_PORT
                value: \"${bootstrap_grpc_port}\"
              - name: SPACEMESH_JSON_PORT
                value: \"${bootstrap_json_port}\"
              - name: SPACEMESH_COINBASE
                value: \"${coin_base}\"
              - name: SPACEMESH_POET_GRPC
                value: \"${poet_url}\"
            args: [ "--config", "/root/config.toml",
                    "--grpc-server", "--grpc-port", \$(SPACEMESH_GRPC_PORT),
                    "--json-server", "--json-port", \$(SPACEMESH_JSON_PORT),
                    "--tcp-port",    \$(SPACEMESH_MINER_PORT),
                    "--coinbase",    \$(SPACEMESH_COINBASE),
                    "--poet-server", \$(SPACEMESH_POET_GRPC),
                  ]
            resources:
              limits:
                cpu: 1000m
              requests:
                cpu: 100m
            volumeMounts:
              - name: miner-storage
                mountPath: /root
  """.stripIndent()
}

def worker_manifest = {pool_id, miner_image, worker_id, tcp_port, grpc_port, json_port ->
  """
  ---
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: miner-${pool_id}-node-${worker_id}
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
      miner-node: miner-${pool_id}-node-${worker_id}
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: miner
    template:
      metadata:
        labels:
          app: miner
          miner-pool: \"${pool_id}\"
          miner-node: miner-${pool_id}-node-${worker_id}
      spec:
        volumes:
          - name: miner-storage
            emptyDir: {}

        initContainers:
          - name: miner-init
            image: \"${init_miner_image}\"
            env:
              - name: SPACEMESH_S3_BUCKET
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_bucket
              - name: SPACEMESH_S3_PREFIX
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_s3_prefix
              - name: SPACEMESH_DYNAMODB_TABLE
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_table
              - name: SPACEMESH_DYNAMODB_REGION
                valueFrom:
                  configMapKeyRef:
                    name: spacemesh-testnet-miner
                    key: initdata_dynamodb_region
              - name: SPACEMESH_WORKDIR
                value: "/root"
              - name: SPACEMESH_DATADIR
                value: "./post/data"

            volumeMounts:
              - name: miner-storage
                mountPath: /root

        containers:
          - name: default
            image: \"${miner_image}\"
            imagePullPolicy: "Always"
            env:
              - name: SPACEMESH_MINER_PORT
                value: \"${tcp_port}\"
              - name: SPACEMESH_GRPC_PORT
                value: \"${grpc_port}\"
              - name: SPACEMESH_JSON_PORT
                value: \"${json_port}\"
              - name: SPACEMESH_COINBASE
                value: \"${coin_base}\"
              - name: SPACEMESH_POET_GRPC
                value: \"${poet_url}\"
            args: [ "--config", "/root/config.toml",
                    "--grpc-server", "--grpc-port", \$(SPACEMESH_GRPC_PORT),
                    "--json-server", "--json-port", \$(SPACEMESH_JSON_PORT),
                    "--tcp-port", \$(SPACEMESH_MINER_PORT),
                    "--coinbase",    \$(SPACEMESH_COINBASE),
                    "--poet-server", \$(SPACEMESH_POET_GRPC),
                    "--bootnodes", \"${bootnodes}\"
                  ]
            resources:
              limits:
                cpu: 1000m
              requests:
                cpu: 100m
            volumeMounts:
              - name: miner-storage
                mountPath: /root
  """.stripIndent()
}

def get_node_inst_id = {node ->
  """
  ${kubectl} get node ${node} --template '{{.spec.providerID}}' | sed -e 's/.\\+\\///'
  """.stripIndent()
}

def get_instance_ip = {inst_id ->
  """
  aws ec2 describe-instances --region=${aws_region} --instance-ids ${inst_id} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text
  """.stripIndent()
}

def get_bootstrap_id = {pod ->
  """
  ${kubectl} logs ${pod} --tail=-1 -f |\\
  sed -ne '/Local node identity / { s/.\\+Local node identity >> \\([a-zA-Z0-9]\\+\\).*/\\1/ ; p; q; }'
  """.stripIndent()
}


/*
  PIPELINE
 */
pipeline {
  agent any

  options {
    buildDiscarder(logRotator(numToKeepStr: '5')) // Keep last 5 builds only
  }

  parameters {
    string name: 'MINER_COUNT', defaultValue: '', description: 'Number of the miners to start', trim: true
    string name: 'MINER_IMAGE', defaultValue: default_miner_image, description: 'Miner pool id', trim: true
    string name: 'POOL_ID',     defaultValue: '', description: 'Miner pool id', trim: true
  }

  stages {
    stage("Prepare") {
      steps {
        script {
          miner_count = params.MINER_COUNT as int
          assert miner_count > 0
          pool_id = params.POOL_ID ?: random_id()
        }
        echo "Number of miners: ${miner_count}"
        echo "Miner pool ID: ${pool_id}"
      }
    }

    stage("Create services") {
      steps {
        script {
          bootstrap_tcp_port  = create_service(pool_id, "miner-${pool_id}-bootstrap", "tcp")
          // Also add UDP service on the same port
          create_udp_service(pool_id, "miner-${pool_id}-bootstrap", bootstrap_tcp_port)
          bootstrap_json_port = create_service(pool_id, "miner-${pool_id}-bootstrap", "json")
          bootstrap_grpc_port = create_service(pool_id, "miner-${pool_id}-bootstrap", "grpc")
        }

        echo """\
          Bootstrap TCP/UDP port: ${bootstrap_tcp_port}
          Bootstrap JSON port: ${bootstrap_json_port}
          Bootstrap GRPC port: ${bootstrap_grpc_port}""".stripIndent()

        script {
          for(i in (1..(miner_count-1)).collect()) {
            def ports = [
                         tcp_port:  create_service(pool_id, "miner-${pool_id}-node-${i}", "tcp"),
                         grpc_port: create_service(pool_id, "miner-${pool_id}-node-${i}", "grpc"),
                         json_port: create_service(pool_id, "miner-${pool_id}-node-${i}", "json"),
                        ]
            create_udp_service(pool_id, "miner-${pool_id}-node-${i}", ports.tcp_port)
            worker_ports.add(ports)
            echo """\
              Worker #${i} TCP/UDP port: ${ports.tcp_port}
              Worker #${i} JSON port: ${ports.json_port}
              Worker #${i} GRPC port: ${ports.grpc_port}""".stripIndent()
          }
        }
      }
    }

    /* FIXME: Add PVC here */

    stage("Create bootstrap miner") {
      steps {
        echo "Generating manifest"
        writeFile file: "bootstrap-${pool_id}-deploy.yml", text: bootstrap_manifest(pool_id, params.MINER_IMAGE)
        echo "Creating bootstrap Deployment"
        sh """${kubectl} create -f bootstrap-${pool_id}-deploy.yml"""
        echo "Waiting for the bootstrap pod to be scheduled..."
        script {
          def pod_node

          /* Wait until a pod in a Running state appears */
          timeout(time: 600, unit: 'SECONDS') {
            waitUntil {
              try {
                (bootstrap_pod, pod_status, pod_node) = shell(get_bootstrap_pod(pool_id, miner_image)).split()
                pod_status == "Running"
              } catch(all) {
                false
              }
            }
          }

          echo "Running on node ${pod_node}, getting AWS instance id"
          def inst_id = shell(get_node_inst_id(pod_node))

          echo "Getting AWS instance '${inst_id}' public IP"
          bootstrap_addr = shell(get_instance_ip(inst_id))
        }
        echo "Bootstrapping from: ${bootstrap_addr}:${bootstrap_tcp_port}"

        echo "Getting bootstrap miner_id from the logs"
        script {
          timeout(time: 600, unit: 'SECONDS') {
            bootstrap_id = shell(get_bootstrap_id(bootstrap_pod))
          }
        }
        echo "Bootstrap ID: ${bootstrap_id}"

        script {
          bootnodes = "spacemesh://${bootstrap_id}@${bootstrap_addr}:${bootstrap_tcp_port}?disport=${bootstrap_tcp_port}"
        }
        echo "Bootstrap nodes: ${bootnodes}"
      }
    }

    stage("Create workers") {
      steps {
        script {
          worker_ports.eachWithIndex({ports, i ->
            i++
            echo "Generating manifest for worker #${i}"
            writeFile file: "miner-${pool_id}-node-${i}-deploy.yml", \
                      text: worker_manifest(pool_id, params.MINER_IMAGE, i,
                                            ports.tcp_port,
                                            ports.grpc_port,
                                            ports.json_port,
                                            )
            echo "Creating Deployment for worker #${i}"
            sh """${kubectl} create -f miner-${pool_id}-node-${i}-deploy.yml"""
          })
        }
      }
    }

    stage("Archive artifacts") {
      steps {
        archiveArtifacts "*-${pool_id}-*.yml"
      }
    }
  }
}

def create_udp_service(pool_id, node, port) {
  def name = "${node}-udp"
  echo "Writing UDP service manifest for ${name}"
  writeFile file: "${name}-svc.yml", text: """
  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: ${name}
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
  spec:
    type: NodePort
    selector:
      miner-node: \"${node}\"
    ports:
    - protocol: UDP
      port: ${port}
  """.stripIndent()

  echo "Creating service"
  sh """${kubectl} create -f ${name}-svc.yml"""
}

def create_service(pool_id, node, name) {
  def svc = "${node}-${name}"
  echo "Writing service manifest for ${svc}"
  writeFile file: "${svc}-svc.yml", text: """
  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: ${svc}
    labels:
      app: miner
      miner-pool: \"${pool_id}\"
  spec:
    type: NodePort
    selector:
      miner-node: \"${node}\"
    ports:
    - protocol: TCP
      port: 9091
  """.stripIndent()

  echo "Creating service"
  sh """${kubectl} create -f ${svc}-svc.yml"""

  echo "Getting allocated port"
  def port = shell("""${kubectl} get svc ${svc} --template '{{(index .spec.ports 0).nodePort}}'""")

  echo "Patching ${svc} targetPort to ${port}"
  sh """\
  ${kubectl} patch service ${svc} \
    -p '
    [
      {
        "op": "replace",
        "path":"/spec/ports/0/port",
        \"value\": ${port}
      },
      {
        "op": "replace",
        "path":"/spec/ports/0/targetPort",
        \"value\": ${port}
      }
    ]' --type json
  """.stripIndent()

  return port
}

/* vim: set filetype=groovy ts=2 sw=2 et : */
